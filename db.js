// console.log("db connected")
import { ENVS } from './envs.js';
/**@type {HTMLFormElement|null} */
const form = document.forms.namedItem("saveForm")

// const faceSVG = document.getElementById("face-svg")

/**
 * @typedef {import('./types/Emoji').Emoji} Emoji
 * @typedef {import('./types/Emoji').NewEmoji} NewEmoji
 * @typedef {import('./types/PouchDBChange').PouchDBChange} PouchDBChange
 */
//? https://pouchdb.com/getting-started.html

if(!ENVS) throw new Error('check envs.js file')
const {DB_PROTOCOL, DB_USER, DB_PASSWORD, DB_COLLECTION, DB_URL} = ENVS

const syncDom = document.querySelector("#sync-state")

const collection = "emoji"
const db = new PouchDB(collection)
const remoteDB = `${DB_PROTOCOL}://${DB_USER}:${DB_PASSWORD}@${DB_URL}/${DB_COLLECTION}`
const opts = { live: true, retry: true }

// TODO have client login to play game
// // Client logs in with username/password
// async function login(username, password) {
//   const response = await fetch('https://couchdb.mydomain.site/_session', {
//     method: 'POST',
//     headers: { 'Content-Type': 'application/json' },
//     body: JSON.stringify({ name: username, password: password })
//   });
//   // CouchDB returns a session cookie
//   return response.json();
// }

//? https://pouchdb.com/api.html#sync
// do one way, one-off sync from the server until completion
db.replicate
	.from(remoteDB)
	.on("complete", function (info) {
		// then two-way, continuous, retriable sync
		syncDom?.setAttribute("data-sync-state", "connected")
		db.sync(remoteDB, opts)
			.on("change", onSyncChange)
			.on("paused", onSyncPaused)
			.on("error", onSyncError)
	})
	.on("error", onSyncError)

/**@param {PouchDBChange} data */
function onSyncChange(data) {
	syncDom?.setAttribute("data-sync-state", "syncing")

	// if (data.change.docs.length > 0) {
	// 	data.change.docs.map((doc) => addLove(doc))
	// }

	// if (data.direction === "pull")
	// 	console.log("add incoming remote data to browser")
	// if (data.direction === "push")
	// 	console.log("should i ignore data already being generated by same client?")
}
function onSyncPaused() {
	// console.log("onSyncPaused")
	syncDom?.setAttribute("data-sync-state", "paused")
}

/**
 *  @param {any} error
 *  @return {void}
 */
function onSyncError(error) {
	if (error) {
		syncDom?.setAttribute("data-sync-state", "error")
		console.log("DB SYNC ERROR: ", error)
	}
}

async function getAllDocs() {
	try {
		const res = await db.allDocs({ include_docs: true })
		// console.log(res)
		res.rows.map((emoji) => renderSVG(emoji.doc.svg))
	} catch (error) {
    console.log('db.js getAllDocs: ', error);
  }
}
getAllDocs()

form?.addEventListener("submit", function (e) {
	e.preventDefault()

	const formData = new FormData(this)
	/** @type {string|null} */
	const name = formData.get("name")
	// const svg = formData.get('svg');
	// console.log(window.faceSVG);
	const clonedSVG = document.getElementById("face-svg")?.cloneNode(true)
	if (!clonedSVG) throw new Error("Face SVG not found")

	// Your logic here
	// console.log("Form submitted:", name)
	createEmoji(name, clonedSVG)
})

/**
 *  @param {string} name
 *  @param {SVGElement} svg
 */
async function createEmoji(name, svg) {
	// 1. remove id
	svg.removeAttribute("id")
	// 2. add style from `parts.css` as <def> <style> in svg
	const css = await fetchCSS("/parts.css")
	let defs = svg.querySelector("defs")
	if (!defs) {
		defs = document.createElementNS("http://www.w3.org/2000/svg", "defs")
		svg.insertBefore(defs, svg.firstChild)
	}
	const style = document.createElementNS("http://www.w3.org/2000/svg", "style")
	style.setAttribute("type", "text/css")
	style.textContent = css
	defs.appendChild(style)
	const svgString = new XMLSerializer().serializeToString(svg)

  // POST to db
	/** @type {NewEmoji} */
	const point = {
		//? if using put instead of post set _id
		// _id: new Date().toISOString(),
		date: new Date().toISOString(),
		name,
		svg: svgString,
	}

	try {
		//? use put if creating a custom id (must be unique)
		// const res = await db.put(point)
		const res = await db.post(point)

		if (res.ok) {
			// console.log("pouchdb ok: ", res.ok)
			const newPoint = {
				...point,
				_id: res.id,
				_rev: res.rev,
			}
      renderSVG(svgString)
			return newPoint
		}

		console.log(res)
	} catch (error) {
		console.log("addLove error: ", error)
	}
}

/** @param {string} svg  */
function renderSVG(svg) {
	const parser = new DOMParser()
	const doc = parser.parseFromString(svg, "image/svg+xml")
	const svgElement = doc.documentElement

	if (svgElement.tagName === "svg") {
		// Insert into DOM safely
		document.getElementById("face-container")?.appendChild(svgElement)
	}
}

/**
 *
 * @param {string} url
 * @returns {Promise<string>}
 */
async function fetchCSS(url) {
	const response = await fetch(url)
	if (!response.ok) throw new Error("Failed to fetch CSS")
	return await response.text()
}

// const db = new PouchDB("love")
// const remoteDB =
// 	"https://love-all:Deliverer-Amusing-Alias8@chao-db.tawtaw.site/love"

// function sync() {
// 	syncDom.setAttribute("data-sync-state", "syncing")
// 	const opts = { live: true, retry: true }
// 	db.replicate.to(remoteDB, opts, onSyncError)
// 	db.replicate.from(remoteDB, opts, onSyncError)
// }
// sync()onSyncChange
